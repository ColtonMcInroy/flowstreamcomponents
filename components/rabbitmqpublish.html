<script total>

	exports.name = 'RabbitMQ Publish';
	exports.icon = 'fa fa-envelope-o';
	exports.author = 'Total Avengers';
	exports.version = '1';
	exports.config = {};
	exports.inputs = [{ id: 'input', name: 'Input' }];
	exports.outputs = [{ id: 'output', name: 'Output' }];

	exports.npm = ['amqp-connection-manager'];
	// exports.meta = { readonly: false, singleton: false, hidden: false };

	exports.make = function(instance, config) {

		var amqp = require('amqp-connection-manager');

		var Manager, channelWrapper;
		var stats = { ack: 0, nack: 0 };
		var state = 'Disconnected';

		// initialy the stack is paused
		var stack = new Stack(instance.id, function(data, next){
			if (!channelWrapper) {
				console.log('No channelWrapper', stack.busy);
				return next(false);
			}

			channelWrapper
				.sendToQueue(instance.options.queuename, Buffer.from(data))
				.then(function () {
					next(true);
					stats.ack++;
					setStatus();
				})
				.catch(function (err) {
					next(false);
					stats.nack++;
					setStatus();
				});
		});

		instance.message = function($) {
			var d = $.data;
			var type = typeof(d);
			if (type !== 'buffer' && type !== 'string')
				d = JSON.stringify(d);

			stack.push(d);
			$.destroy();
		};

		function setStatus() {
			instance.status(`${state} | Ack:${stats.ack} | Nack:${stats.nack}`);
		};

		instance.configure = function configure(o, oldopts) {

			instance.status('Reconfiguring..');

			if (!config.hostname || !config.queuename) // queue name is optional in some cases, not supported here
				return instance.status('Not configured', 'red');

			config.port = config.port || 5672;
			config.vhost = config.vhost || '/';
			if (config.vhost[0] !== '/')
				config.vhost = '/' + config.vhost;

			var credentials = '';
			if (config.username)
				credentials += config.username;
			if (config.password)
				credentials += ':' + config.password;
			if (credentials)
				credentials += '@';

			var conString = `${config.protocol}://${credentials}${config.hostname}:${config.port}${config.vhost}`;

			// Create a new connection manager
			Manager = amqp.connect([conString]);
			Manager.on('connect', function(){
				state = 'Connected';
				setStatus();
				console.log('Rabbit Connected');
			});
			Manager.on('disconnect', function(e){
				state = 'Disconnected';
				setStatus();
				console.log('Rabbit Disconnected', e);
			});
			Manager.on('error', function(e){
				state = 'Error';
				setStatus();
				console.log('Rabbit Error', e);
			});

			// Ask the connection manager for a ChannelWrapper.  Specify a setup function to
			// run every time we reconnect to the broker.
			channelWrapper = Manager.createChannel({
				setup: function (channel) {
					// `channel` here is a regular amqplib `ConfirmChannel`.
					// Note that `this` here is the channelWrapper instance.
					return channel.assertQueue(config.queuename, { durable: true });
				},
			});

		};

		instance.close = function(){
			stack.destroy();
			stack = null;
			Manager.close();
		};

		function Stack(id, callback) {
			var self = this;
			self.dbname = 'amqp_stack_' + id;
			self.index = 1;
			self.callback = callback;
			self.busy = false;
			self.db = NOSQL(self.dbname);
			NOSQLMEMORY(self.dbname);
		};

		Stack.prototype.destroy = function() {
			clearTimeout(this.timeout);
			this.busy = true;
			this.callback = () => {};
			this.data = null;
		};

		Stack.prototype.next = function() {
			var self = this;
			if (self.busy)
				return;
			self.busy = true;
			if (self.timeout) {
				clearTimeout(self.timeout);
				self.timeout = null;
			}
			self.db.top(1).callback(function(err, data){
				if (data && data.length) {
					var id = data[0].id;
					var data = data[0].data;
					self.callback(data, function(ok){
						if (ok) {
							self.db.remove().where('id', id).callback(function(){
								self.busy = false;
								self.next();
							});
						} else {
							self.busy = false;
							self.timeout = setTimeout(function(){
								self.next();
							}, 3000);
						}
					});
				} else
					self.busy = false;
			});
		};

		Stack.prototype.push = function(data) {
			this.db.insert({ id: this.index++, data: data });
			this.next();
		};
	};

</script>

<readme>
Markdown readme

```js
var total = 'Hello world!';
```
</readme>

<settings>
	<div class="padding">
		<div class="row">
			<div class="col-md-6">
				<div data-jc="input__?.hostname__placeholder:localhost;required:1" class="m">@(Hostname or IP address)</div>
			</div>
			<div class="col-md-6">
				<div data-jc="input__?.port__placeholder:5672" class="m">@(Port) (default: 5672)</div>
			</div>
		</div>
		<div class="row">
			<div class="col-md-6">
				<div data-jc="dropdown__?.protocol__items:amqp|amqp,amqps|amqps" class="m" data-jc-value="'amqp'">@(Protocol)</div>
			</div>
			<div class="col-md-6">
				<div data-jc="input__?.vhost__placeholder:/" class="m">@(Virtual host)</div>
			</div>
		</div>
		<div class="row">
			<div class="col-md-6">
				<div data-jc="input__?.queuename__required:1" class="m">@(Queue name)</div>
			</div>
		</div>
		<div class="row">
			<div class="col-md-6">
				<div data-jc="input__?.username" class="m">@(Username)</div>
			</div>
			<div class="col-md-6">
				<div data-jc="input__?.password__type:password" class="m">@(Password)</div>
			</div>
		</div>
	</div>
</settings>

<style>
	.CLASS footer { padding: 10px; font-size: 12px; }
</style>

<script>

</script>

<body>
	<header>
		<i class="ICON"></i>NAME
	</header>
	<footer dataa-bind="!STATUS__text"></footer>
</body>